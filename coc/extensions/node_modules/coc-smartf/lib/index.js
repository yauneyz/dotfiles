var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  activate: () => activate
});
var import_coc2 = __toModule(require("coc.nvim"));

// src/manager.ts
var import_coc = __toModule(require("coc.nvim"));

// src/util.ts
function getPositions(character, lines, matchWord, offset = 0) {
  let positions = [];
  let i = 0;
  let isWordChar = wordChar(character);
  for (let line of lines) {
    let start = i == 0 ? offset : 0;
    for (let j = start; j < line.length; j++) {
      if (line[j] == character) {
        if (!matchWord || !isWordChar || (j == 0 || !wordChar(line[j - 1]))) {
          positions.push({ line: i, character: j });
        }
      }
    }
    i++;
  }
  return positions;
}
function wordChar(ch) {
  let code = ch.charCodeAt(0);
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}

// src/manager.ts
var characters = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "0",
  ",",
  "."
];
var Manager = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.matchIds = [];
    this.activated = false;
    this.hasIndentLine = false;
    this.positionMap = new Map();
    this.isForward = true;
    this.conceallevel = 0;
    this.concealcursor = "";
    this.charsIgnoreByNavigator = [];
    let config = import_coc.workspace.getConfiguration("smartf");
    this.charsIgnoreByNavigator = config.get("charactersIgnoreByNavigator", []);
    characters = characters.filter((c) => {
      return this.charsIgnoreByNavigator.indexOf(c) === -1;
    });
    this.timeout = config.get("timeout", 1e3);
    this.jumpOnTrigger = config.get("jumpOnTrigger", true);
    this.wordJump = config.get("wordJump", true);
    this.singleCharacterJump = config.get("singleCharacterJump", false);
  }
  async forward() {
    await this.jump();
  }
  async backward() {
    await this.jump(false);
  }
  async repeat() {
    await this.jump(this.isForward, this.character);
  }
  async repeatOpposite() {
    await this.jump(!this.isForward, this.character);
  }
  async jump(isForward = true, character) {
    let { nvim } = this;
    this.positionMap.clear();
    let ids = await nvim.eval('get(w:,"indentLine_indentLineId",0)');
    this.hasIndentLine = Array.isArray(ids) && ids.length > 0;
    nvim.pauseNotification();
    nvim.call("win_getid", [], true);
    nvim.call("coc#util#cursor", [], true);
    nvim.call("line", ["w0"], true);
    nvim.call("getline", ["."], true);
    nvim.call("eval", [`getline(line('w0'), line('w$'))`], true);
    nvim.call("eval", ["&conceallevel"], true);
    nvim.call("eval", ["&concealcursor"], true);
    nvim.command(`normal! m'`, true);
    if (this.hasIndentLine) {
      nvim.command("silent! IndentLinesDisable", true);
    }
    nvim.command(`setl conceallevel=2`, true);
    nvim.command(`setl concealcursor=n`, true);
    let [res, err] = await nvim.resumeNotification();
    if (err) {
      import_coc.window.showMessage(`Error on ${err[0]}: ${err[1]} - ${err[2]}`, "error");
      return;
    }
    this.activated = true;
    let [winid, cursor, startline, currline, lines, conceallevel, concealcursor] = res;
    this.winid = winid;
    this.conceallevel = conceallevel;
    this.concealcursor = concealcursor;
    if (!character) {
      character = await import_coc.workspace.callAsync("coc#list#getchar", []);
      this.isForward = isForward;
      this.character = character;
    }
    let offset = 0;
    if (!isForward) {
      let count = cursor[0] - (startline - 1) + 1;
      lines = lines.slice(0, count);
      lines[lines.length - 1] = currline.slice(0, cursor[1]);
    } else {
      offset = cursor[1] + 1;
      lines = lines.slice(cursor[0] - (startline - 1));
    }
    let positions = getPositions(character, lines, this.wordJump, offset);
    if (positions.length == 0) {
      await this.reset();
      return;
    }
    if (!isForward)
      positions.reverse();
    let currpos;
    if (this.jumpOnTrigger) {
      let first = positions.shift();
      let col = byteIndex(lines[first.line], first.character) + 1;
      let line = startline + first.line + (isForward ? cursor[0] + 1 - startline : 0);
      await nvim.call("cursor", [line, col]);
      currpos = [line, col];
    } else {
      let [, line, col] = await nvim.call("getpos", ["."]);
      currpos = [line, col];
    }
    if (positions.length == 0) {
      await this.reset();
      return;
    }
    if (this.singleCharacterJump) {
      return;
    }
    this.positionMap.clear();
    let remains = [];
    for (let i = 0; i < positions.length; i++) {
      let pos = positions[i];
      let ch = characters[i];
      let line = startline + pos.line + (isForward ? cursor[0] + 1 - startline : 0);
      let col = byteIndex(lines[pos.line], pos.character) + 1;
      if (ch) {
        this.positionMap.set(ch, { character: ch, position: [line, col] });
      } else {
        remains.push([line, col]);
      }
    }
    this.repeatPosition = remains[0];
    await nvim.call("coc#util#do_autocmd", ["SmartfEnter"]);
    nvim.pauseNotification();
    for (let val of this.positionMap.values()) {
      let { position, character: character2 } = val;
      let pos = [position[0], position[1], 1];
      nvim.call("matchaddpos", ["Conceal", [pos], 999, -1, { conceal: character2 }], true);
    }
    nvim.call("matchaddpos", ["Cursor", [[currpos[0], currpos[1], 1]], 99], true);
    for (let val of remains) {
      let pos = [val[0], val[1], 1];
      nvim.call("matchaddpos", ["Conceal", [pos], 999, -1, { conceal: ";" }], true);
    }
    let result = await nvim.resumeNotification();
    if (result[1]) {
      let err2 = result[1];
      console.error(`Error on activate smartf, ${err2[0]}: ${err2[1]} - ${err2[2]}`);
      return;
    }
    this.matchIds = result[0];
    this.getCharacter().catch((e) => {
      console.error(e);
    });
  }
  async getCharacter() {
    let p = import_coc.workspace.callAsync("coc#list#getchar", []);
    let finished = false;
    setTimeout(async () => {
      if (finished)
        return;
      this.nvim.command(`call feedkeys("\\<esc>", 'in')`, true);
      await this.cancel();
    }, this.timeout || 1e3);
    let ch = await p;
    finished = true;
    if (this.charsIgnoreByNavigator.indexOf(ch) !== -1) {
      await this.cancel();
      this.nvim.command(`call feedkeys("${ch}", 'in')`, true);
    } else if (ch == ";" && this.repeatPosition) {
      await this.cancel();
      this.nvim.call("cursor", this.repeatPosition, true);
      this.jump(this.isForward, this.character).catch((_e) => {
      });
    } else {
      let val = this.positionMap.get(ch);
      await this.cancel();
      if (val)
        this.nvim.call("cursor", val.position, true);
    }
  }
  async reset() {
    this.activated = false;
    let { nvim } = this;
    if (this.hasIndentLine) {
      nvim.command("silent! IndentLinesEnable", true);
    }
    nvim.pauseNotification();
    nvim.command(`setl conceallevel=${this.conceallevel}`, true);
    nvim.command(`setl concealcursor=${this.concealcursor}`, true);
    await nvim.resumeNotification();
  }
  async cancel() {
    let { nvim, matchIds, winid } = this;
    if (!this.activated)
      return;
    this.activated = false;
    nvim.pauseNotification();
    if (this.hasIndentLine) {
      nvim.command("silent! IndentLinesEnable", true);
    }
    nvim.command(`setl conceallevel=${this.conceallevel}`, true);
    nvim.command(`setl concealcursor=${this.concealcursor}`, true);
    nvim.call("coc#util#do_autocmd", ["SmartfLeave"], true);
    if (matchIds.length && winid) {
      nvim.call("coc#highlight#clear_matches", [this.winid, this.matchIds], true);
    }
    this.matchIds = [];
    await nvim.resumeNotification();
  }
};
function byteIndex(content, index) {
  let s = content.slice(0, index);
  return Buffer.byteLength(s);
}

// src/index.ts
async function activate(context) {
  let { subscriptions } = context;
  let manager = new Manager(import_coc2.workspace.nvim);
  subscriptions.push(import_coc2.workspace.registerKeymap(["n"], "smartf-forward", async () => {
    await manager.forward();
  }, { sync: false, cancel: true, silent: true }));
  subscriptions.push(import_coc2.workspace.registerKeymap(["n"], "smartf-backward", async () => {
    await manager.backward();
  }, { sync: false, cancel: true, silent: true }));
  subscriptions.push(import_coc2.workspace.registerKeymap(["n"], "smartf-repeat", async () => {
    await manager.repeat();
  }, { sync: false, cancel: true, silent: true }));
  subscriptions.push(import_coc2.workspace.registerKeymap(["n"], "smartf-repeat-opposite", async () => {
    await manager.repeatOpposite();
  }, { sync: false, cancel: true, silent: true }));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
//# sourceMappingURL=index.js.map
